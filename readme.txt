Dong Joon Kim djkim02@ucla.edu
Joshua St. Clair joshstclair@ucla.edu
PART A:
DJ took care of the load function and since it was very straightforward, he did not require any help from Josh. During the next portion, the work will be divided up more evenly.
PART B:
After analyzing the code, we agreed that insertAndSplit would probably be the hardest function to implement. We decided not to really alter the structure for BTreeLeaf and BTreeNonLeafNode and simply implement the functions already declared.We divided up the work by functions. Josh implemented the insertAndSplit function for both types of nodes and DJ implemented all the other functions. Josh also created a new project to debug our functions for BTreeNode. This project contained only the necessary header files for BTreeNode to run on its own. We used a series of print statements to view the contents of our nodes while we tested different functions.
PART C:
After reading the spec, we realized that insert function for BTreeIndex is closely related to insert and insertAndSplit functions in BTreeNode and locate and readForward functions are closely related to locate, readEntry, and setNextNodePtr functions in BTreeNode. Therefore, we divided up the work by functions, just as we did for Part B. Since Josh worked on insert and insertAndSplit functions in BTreeNode, he worked on implementing insert, open, and close functions in BTreeIndex and DJ worked on implementing locate and readForward functions. Since we have not actually implemented using the index for BruinBase, we were not sure how to actually debug and test our completed codes until Part D is finished. Therefore, we will continue testing / editing the code (if necessary) after we finish with Part D.
We are using 1 day of grace period for Part C.
PART D:
DJ handled fixing the SqlEngine load function since he worked on it for part A already. Josh handled the select function by altering the loop that was already implemented but using various 'if' conditions to test for greater than, less than, equality etc. conditions. Because we did not test during part C, we encountered many difficulties debugging. The first problem came when we realized we weren't saving our keyCount variable for each node. Because it was not being saved in the disk, it was getting lost everytime we were loading the node from PageFile. We tried storing it in the buffer but that caused many other problems (seg faults). So we changed our implementation for calculating keyCount by zeroing out the buffer instead and counting the used bytes. That, in turn, affected our insertAndSplit function. Even though it was thoroughly debugged before, we had to re-debug it to catch other errors we were having where we were losing the end keys when we split. All in all, we realized the importance of unit testing, early on. We are using our remaining grace days for part d.